#include "path.h"
#include "string.h"
#include "stdlib.h"
#include "ctype.h"
#include "stdio.h"
#include "stdbool.h"
#include "utility.h"

Path* read_path(char* pathString, int playerCount) {
    // Check if the string is '\n' terminated
    if (pathString == NULL || pathString[strlen(pathString) - 1] != '\n') {
        return NULL;
    }

    // Check for the number of barriers
    char* invalidChar;
    char* numOfSitesString = strtok(pathString, ";");
    int numOfSites = strtol(numOfSitesString, &invalidChar, 10);
    if (invalidChar[0] != '\0') {
        return NULL;
    }
    char* sites = strtok(NULL, ";");
    if (strlen(sites) % SITE_LENGTH != 1) {
        return NULL;
    }
    
    Site* pathSites = (Site*) malloc(sizeof(Site) * numOfSites);
    char* sitePlayerCapacities = (char*) malloc(sizeof(char) * numOfSites);
    int capacityIndex = 2;
    int siteNum = 0;
    for (int i = 0; i < (int) strlen(sites) - 1; i += SITE_LENGTH) {
        char siteString[SITE_LENGTH + 1];
        str_splice(siteString, sites, i, i + SITE_LENGTH);
        Site site = get_site(siteString);
        if (site != SITE_ERROR_TYPE) {
            pathSites[siteNum] = site;
        } else {
            free(pathSites);
            free(sitePlayerCapacities);
            return NULL;
        }
        sitePlayerCapacities[siteNum] = siteString[capacityIndex];
        siteNum++;
    }
    if (pathSites[0] != BARRIER || pathSites[numOfSites - 1] != BARRIER) {
        free(pathSites);
        free(sitePlayerCapacities);
        return NULL;
    }


    Path* path = create_path(numOfSites, playerCount, pathSites, 
            sitePlayerCapacities);
    free(pathSites);
    free(sitePlayerCapacities);
    return path;
}

Path* create_path(int numOfSites, int playerCount, Site* sites, 
        char* sitePlayerCapacities) {
    Path* path = (Path*) malloc (sizeof(Path));
    path->numOfSites = numOfSites;
    path->playerCount = playerCount;

    path->sites = (Site*) malloc(sizeof(Site) * numOfSites);
    path->sitePlayerCapacities = (char*) malloc(sizeof(char) * numOfSites);
    path->playerPositions = (int**) malloc(sizeof(char*) * numOfSites);

    for (int i = 0; i < numOfSites; i++) {
        path->sites[i] = sites[i];
        path->sitePlayerCapacities[i] = sitePlayerCapacities[i];
        path->playerPositions[i] = (int*) malloc(sizeof(int) * playerCount);
    }

    for (int siteNum = 0; siteNum < numOfSites; siteNum++) {
        for (int playerID = 0; playerID < playerCount; playerID++) {
            if (siteNum == 0) {
                path->playerPositions[siteNum][playerID] = playerID;
            } else {
                path->playerPositions[siteNum][playerID] = UNOCCUPIED;
            }
        }
    }
    return path;
}

void free_path(Path* path) {
    for (int i = 0; i < path->numOfSites; i++) {
        free(path->playerPositions[i]);
    }
    free(path->playerPositions);
    free(path->sites);
    free(path->sitePlayerCapacities);
    free(path);
}

void print_path(Path* path, FILE* file) {
    // Get size of string
    int numOfBarriers = 0;
    for (int i = 0; i < path->numOfSites; i++) {
        if (path->sites[i] == BARRIER) {
            numOfBarriers++;
        }
    }
    int pathStringSize = numOfBarriers * 3 + 
            (path->numOfSites - numOfBarriers) * 4;
    char* pathString = (char*) calloc(pathStringSize, sizeof(char));
    char** positionStrings = (char**) malloc(
            sizeof(char*) * path->playerCount);
    for (int i = 0; i < path->playerCount; i++) {
        positionStrings[i] = (char*) malloc(sizeof(char) * pathStringSize);
        for (int j = 0; j < pathStringSize; j++) {
            positionStrings[i][j] = ' ';
        }
    }

    int pathStringIndex = 0;
    int siteOffset[path->numOfSites];

    // Get site labels
    for (int i = 0; i < path->numOfSites; i++) {
        siteOffset[i] = pathStringIndex;
        Site site = path->sites[i];
        strncat(pathString, get_site_string(site), 2);
        pathStringIndex += 2;
        if (site != BARRIER) {
            pathString[pathStringIndex++] = path->sitePlayerCapacities[i];
        }
        pathString[pathStringIndex++] = ' ';
    }

    for (int playerID = 0; playerID < path->playerCount; playerID++) {
        positionStrings[playerID][siteOffset[
                get_player_site_num(path, playerID)]] = playerID + '0';
    }
    fprintf(file, "%s\n", pathString);
    for (int playerID = 0; playerID < path->playerCount; playerID++) {
        fprintf(file, "%s\n", positionStrings[playerID]);
    }

    free(pathString);
    for (int playerID = 0; playerID < path->playerCount; playerID++) {
        free(positionStrings[playerID]);
    }
    free(positionStrings);
}

int get_player_site_num(Path* path, int playerID) {
    for (int i = 0; i < path->playerCount; i++) {
        for (int siteNum = 0; siteNum < path->numOfSites; siteNum++) {
            if (path->playerPositions[siteNum][i] == playerID) {
                return siteNum;
            }
        }
    }
    return -1;
}

Site get_site(char* site) {
    if (strlen(site) != 3) {
        return SITE_ERROR_TYPE;
    }
    if (!strcmp(site, "::-")) {
        return BARRIER;
    }
    if (!isdigit(site[2]) || site[2] - '0' == 0) {
        return SITE_ERROR_TYPE;
    }
    char* sites[] = {"Mo", "V1", "V2", "Do", "Ri"};
    for (int i = 0; i < 5; i++) {
        char siteLabel[3];
        str_splice(siteLabel, site, 0, 2);
        if (!strcmp(siteLabel, sites[i])) {
            return i;
        }
    }
    return SITE_ERROR_TYPE;
}

char* get_site_string(Site site) {
    switch (site) {
        case BARRIER:
            return "::";
        case MO:
            return "Mo";
        case V1:
            return "V1";
        case V2:
            return "V2";
        case DO:
            return "Do";
        case RI:
            return "Ri";
        case SI:
            return "Si";
        default:
            return NULL;
    }
}

bool site_occupied(Path* path, int siteNum) {
    int sitePlayerCount = 0;
    for (int i = 0; i < path->playerCount; i++) {
        if (path->playerPositions[siteNum][i] != UNOCCUPIED) {
            sitePlayerCount++;
        }
    }
    if (sitePlayerCount == path->sitePlayerCapacities[siteNum]) {
        return true;
    }
    return false;
}

int get_next_barrier(int currentSite, Path* path) {
    for (int i = currentSite + 1; i < path->numOfSites; i++) {
        if (path->sites[i] == BARRIER) {
            return i;
        }
    }
    return -1;
}

