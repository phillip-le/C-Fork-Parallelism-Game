#include "coms.h"
#include "game.h"
#include "player.h"
#include "errors.h"
#include "deck.h"
#include "stdlib.h"
#include "utility.h"
#include <string.h>

void recv_dealer_msg(Game* game, int pid, char* msg) {
    if (!strcmp(msg, "YT")) {
        printf("DO%d\n", get_playerA_move(game, pid));
        return;
    }
    if (!strcmp(msg, "EARLY")) {
        exit(EARLY_GAME_END);
    }
    if (!strcmp(msg, "DONE")) {
        exit(PLAYER_OK);
    }
    // Program will exit if an error occurred
    recv_player_update(game, msg);
}

void send_player_update(Dealer* dealer, int pid, int destSite) {
    if (!valid_move(dealer->game, pid, destSite)) {
        exit(dealer_error_msg(DEALER_COMS));
    }
    int* updateInfo = get_player_update(dealer->game->path, 
            dealer->game->players[pid], destSite, dealer->nextCard);
    next_card(dealer);
    dealer->game->turnCounter++;
    update_player(dealer->game->path, dealer->game->players[pid], updateInfo, 
            dealer->game->turnCounter);
    write_player_update(updateInfo);
    print_path(stdout, dealer->game);
    free(updateInfo);
}

void write_player_update(int* updateInfo) {
    char* update = (char*) calloc(30, sizeof(char));
    sprintf(update, "HAP%d,%d,%d,%d,%d\n", updateInfo[PLAYER_ID_INDEX],
            updateInfo[NEW_SITE_INDEX], updateInfo[POINTS_INDEX],
            updateInfo[MONEY_INDEX], updateInfo[CARD_INDEX]);
    fprintf(stdout, "%s", update);
    fflush(stdout);
    free(update);
}

int* get_player_update(Path* path, Player* player, int destSite, 
        CARDS nextCard) {
    int* updateInfo = (int*) calloc(5, sizeof(int));
    switch (path->sites[destSite]) {
        case MO:
            updateInfo[MONEY_INDEX] = 3;
            break;
        case DO:
            updateInfo[POINTS_INDEX] = player->points + 
                    (int) player->money / 2;
            updateInfo[MONEY_INDEX] = player->money * -1;
            break;
        case RI:
            updateInfo[CARD_INDEX] = nextCard;
            break;
        case SITE_ERROR_TYPE:
            free(updateInfo);
            return NULL;
        default:
            break;
    }
    updateInfo[PLAYER_ID_INDEX] = player->pid;
    updateInfo[NEW_SITE_INDEX] = destSite;
    return updateInfo;
}

void recv_player_update(Game* game, char* update) {
    int* updateInfo = read_player_update(game, update);
    int pid = updateInfo[PLAYER_ID_INDEX];
    game->turnCounter++;
    update_player(game->path, game->players[pid], updateInfo, 
            game->turnCounter);
    print_player_update(stderr, game->players[pid]);
    print_path(stderr, game);
}

int* read_player_update(Game* game, char* update) {
    int msgStartLength = 3;
    char msgStart[msgStartLength + 1];
    str_splice(msgStart, update, 0, msgStartLength);
    if (strcmp(msgStart, "HAP")) {
        exit(player_error_msg(PLAYER_COMS));
    }
    char infoString[strlen(update) - msgStartLength + 1];

    str_splice(infoString, update, msgStartLength, strlen(update));
    int* info = (int*) calloc(5, sizeof(int));
    char* invalidChar;
    char* intString = strtok(infoString, ",");
    info[0] = strtol(intString, &invalidChar, 10);
    if (invalidChar[0] != '\0') {
        free(info);
        exit(player_error_msg(PLAYER_COMS));
    }
    for (int i = 1; i < 5; i++) {
        intString = strtok(NULL, ",");
        info[i] = strtol(intString, &invalidChar, 10);
        if (invalidChar[0] != '\0') {
            free(info);
            exit(player_error_msg(PLAYER_COMS));
        }
    }
    int pid = info[PLAYER_ID_INDEX];
    if (pid < 0 || pid >= game->playerCount || !valid_move(game, pid, 
            info[NEW_SITE_INDEX]) || info[CARD_INDEX] < 0 || 
            info[CARD_INDEX] > 5) {
        free(info);
        exit(player_error_msg(PLAYER_COMS));
    }
    return info;
}

void print_player_update(FILE* file, Player* player) {
    fprintf(file, "Player %d Money=%d V1=%d V2=%d ",
            player->pid, player->money, player->V1, player->V2);
    int* cardCounters = get_card_counters(player->deck);
    fprintf(file, "Points=%d A=%d B=%d C=%d D=%d E=%d\n", 
            player->points, cardCounters[0], cardCounters[1], cardCounters[2],
            cardCounters[3], cardCounters[4]);
    fflush(file);
    free(cardCounters);
}

void print_path(FILE* file, Game* game) {
    int pathStringSize = game->path->numOfSites * 3 + 1;
    // Stores the highest number of players at any site
    int highestSiteOccupancy = get_highest_occupied(game);
    char* pathString = (char*) calloc(pathStringSize, sizeof(char));
    char** positionStrings = create_position_strings(highestSiteOccupancy,
            pathStringSize);
    int siteOffset[game->path->numOfSites];
    // Get site labels
    int pathStringIndex = 0;
    for (int i = 0; i < game->path->numOfSites; i++) {
        siteOffset[i] = pathStringIndex;
        Site site = game->path->sites[i];
        strncat(pathString, get_site_string(site), 2);
        pathStringIndex += 2;
        pathString[pathStringIndex++] = ' ';
    }
    fill_position_strings(game, positionStrings, highestSiteOccupancy, 
            siteOffset);
    fprintf(file, "%s\n", pathString);
    for (int i = 0; i < highestSiteOccupancy; i++) {
        fprintf(file, "%s\n", positionStrings[i]);
    }
    fflush(file);
    free(pathString);
    for (int i = 0; i < highestSiteOccupancy; i++) {
        free(positionStrings[i]);
    }
    free(positionStrings);
}

int get_highest_occupied(Game* game) {
    int playerSites[game->playerCount];
    for (int i = 0; i < game->playerCount; i++) {
        playerSites[i] = game->players[i]->currentSite;
    }
    int numOfSites = game->path->numOfSites;
    int siteCounters[numOfSites];
    for (int i = 0; i < numOfSites; i++) {
        siteCounters[i] = 0;
    }
    for (int i = 0; i < game->playerCount; i++) {
        siteCounters[playerSites[i]]++;
    }
    return max(siteCounters, numOfSites);
}

char** create_position_strings(int highestSiteOccupancy, int pathStringSize) {
    char** positionStrings = (char**) malloc(
            sizeof(char*) * highestSiteOccupancy);
    for (int i = 0; i < highestSiteOccupancy; i++) {
        positionStrings[i] = (char*) malloc(sizeof(char) * pathStringSize);
        for (int j = 0; j < pathStringSize; j++) {
            positionStrings[i][j] = ' ';
        }
    }
    return positionStrings;
}

void fill_position_strings(Game* game, char** positionStrings, 
        int highestSiteOccupancy, int* siteOffset) {
    int turnOrder[game->playerCount];
    get_turn_order(game, turnOrder);
    for (int i = 0; i < game->playerCount; i++) {
        int pid = turnOrder[i];
        int siteNum = game->players[pid]->currentSite;
        for (int j = 0; j < highestSiteOccupancy; j++) {
            if (positionStrings[j][siteOffset[siteNum]] == ' ') {
                positionStrings[j][siteOffset[siteNum]] = pid + '0';
                break;
            }
        }
    }
}

