#include "stdlib.h"
#include "game.h"
#include "player.h"
#include "path.h"
#include "utility.h"

int get_move(Game* game, int pid) {
    int currentSite = game->players[pid]->currentSite;
    int nextSite = currentSite + 1;
    // Check if can go to nextSite
    Player* players[game->playerCount];
    for (int i = 0; i < game->playerCount; i++) {
        players[i] = game->players[i];
    }
    sort_players_by_site(players, game->playerCount);
    if (!site_occupied(game, nextSite)) {
        if (game->playerCount == 1) {
            return nextSite;
        } else if (players[0]->pid == pid && 
                players[1]->currentSite > currentSite) {
            return nextSite;
        }
    }
    int numOfOptions = 4;
    int* siteOptions = (int*) calloc(game->path->numOfSites, sizeof(int));
    for (int i = 0; i < numOfOptions; i++) {
        siteOptions[i] = game->path->numOfSites;
    }
    // Check if can go to next Mo site
    if (game->players[pid]->money % 2 == 1 && 
            get_next_site(game, pid, MO) != -1) {
        siteOptions[0] = get_next_site(game, pid, MO);
    }
    
    // Check if can go to next Ri site
    int playerCardCounts[game->playerCount];
    for (int i = 0; i < game->playerCount; i++) {
        playerCardCounts[i] = game->players[i]->deck->cardCount;
    }
    int maxCardCount = max(playerCardCounts, game->playerCount);
    if ((game->players[pid]->deck->cardCount == maxCardCount || 
            maxCardCount == 0) && get_next_site(game, pid, RI) != -1) {
        siteOptions[1] = get_next_site(game, pid, RI);
    }

    // Check if can go to next V2 site
    if (get_next_site(game, pid, V2) != -1) {
        siteOptions[2] = get_next_site(game, pid, V2);
    }

    // Get the next unoccupied site
    for (int i = nextSite; i < game->path->numOfSites; i++) {
        if (!site_occupied(game, i)) {
            siteOptions[3] = i;
            break;
        }
    }
    int destSite = min(siteOptions, numOfOptions);
    free(siteOptions);
    return destSite;
}