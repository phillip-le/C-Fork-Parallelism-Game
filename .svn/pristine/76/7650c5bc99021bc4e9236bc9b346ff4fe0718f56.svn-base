#include "game.h"
#include "path.h"
#include "player.h"
#include "errors.h"
#include "deck.h"
#include "stdbool.h"
#include "utility.h"
#include "stdlib.h"

Game* init_game(int gid, int playerCount, char* pathString) {
    Game* game = (Game*) malloc(sizeof(Game));
    game->gid = gid;
    game->playerCount = playerCount;
    game->turnCounter = 0;
    game->path = read_path(pathString, playerCount);
    if (game->path == NULL) {
        free(game);
        return NULL;
    }
    game->players = (Player**) malloc(sizeof(Player*) * playerCount);
    for (int i = 0; i < playerCount; i++) {
        game->players[i] = init_player(i);
    }
    return game;
}

void free_game(Game* game) {
    free_players(game->players, game->playerCount);
    free_path(game->path);
    free(game);
}

int get_next_turn(Game* game) {
    int turnOrder[game->playerCount];
    get_turn_order(game, turnOrder);
    return turnOrder[0];
}

void get_turn_order(Game* game, int* turnOrder) {
    Player* players[game->playerCount];
    for (int i = 0; i < game->playerCount; i++) {
        players[i] = game->players[i];
    }
    sort_players_by_site(players, game->playerCount);
    sort_players_same_site(players, game->playerCount);
    for (int i = 0; i < game->playerCount; i++) {
        turnOrder[i] = players[i]->pid;
    }
}

void sort_players_by_site(Player** players, int playerCount) {
    bool sorted = false;
    while (!sorted) {
        sorted = true;
        for (int i = 0; i < playerCount - 1; i++) {
            if (players[i]->currentSite > players[i + 1]->currentSite) {
                swap_players(players, i, i + 1);
                sorted = false;
            }
        }
    }
}

void sort_players_same_site(Player** players, int playerCount) {
    bool sorted = false;
    while (!sorted) {
        sorted = true;
        for (int i = 0; i < playerCount - 1; i++) {
            if (players[i]->currentSite == players[i + 1]->currentSite) {
                if (players[i]->lastTurn < players[i + 1]->lastTurn) {
                    swap_players(players, i, i + 1);
                    sorted = false;
                } else if (players[i]->lastTurn == players[i + 1]->lastTurn &&
                        players[i]->pid < players[i + 1]->pid) {
                    swap_players(players, i, i + 1);
                    sorted = false;
                }
            }
        }
    }
}

Dealer* init_dealer(int playerCount, char* deckString, 
        char* pathString) {
    Dealer* dealer = (Dealer*) malloc(sizeof(Dealer));
    dealer->game = init_game(DEALER_ID, playerCount, pathString);
    if (dealer->game == NULL) {
        exit(dealer_error_msg(BAD_PATH));
    }
    dealer->deck = read_deck(deckString);
    if (dealer->deck == NULL) {
        exit(dealer_error_msg(BAD_DECK));
    }
    dealer->nextCard = 0;
    return dealer;
}

void next_card(Dealer* dealer) {
    dealer->nextCard++;
    if (dealer->nextCard == dealer->deck->cardCount) {
        dealer->nextCard = 0;
    }
}

void swap_players(Player** players, int i, int j) {
    Player* temp = players[i];
    players[i] = players[j];
    players[j] = temp;
}

bool valid_move(Game* game, int pid, int destSite) {
    if (site_occupied(game, destSite)) {
        return false;
    }
    if (destSite > get_next_barrier(
            game->path, game->players[pid]->currentSite)) {
        return false;
    }
    return true;
}

bool site_occupied(Game* game, int siteNum) {
    int sitePlayerCount = 0;
    for (int i = 0; i < game->playerCount; i++) {
        if (game->players[i]->currentSite == siteNum) {
            sitePlayerCount++;
        }
    }
    if (sitePlayerCount >= game->path->sitePlayerCapacities[siteNum]) {
        return true;
    }
    return false;
}

bool game_over(Game* game) {
    for (int i = 0; i < game->playerCount; i++) {
        if (!(game->players[i]->currentSite == game->path->numOfSites - 1)) {
            return false;
        }
    }
    return true;
}

int get_playerA_move(Game* game, int pid) {
    int currentSite = game->players[pid]->currentSite;
    int nextSite = currentSite + 1;
    int nextBarrier = get_next_barrier(game->path, currentSite);
    for (int i = nextSite; i < nextBarrier; i++) {
        if (valid_move(game, pid, i) && 
                game->path->sites[i] == DO) {
            return i;
        }
    }
    if (valid_move(game, pid, nextSite) && 
            game->path->sites[nextSite] == MO) {
        return nextSite;
    }
    for (int i = nextSite; i < nextBarrier; i++) {
        if (valid_move(game, pid, i)) {
            Site site = game->path->sites[i];
            if (site == V1 || site == V2 || site == BARRIER) {
                return i;
            }
        }
    }
    return -1;
}

int get_playerB_move(Game* game, int pid) {
    int currentSite = game->players[pid]->currentSite;
    int nextSite = currentSite + 1;
    // Check if can go to nextSite
    Player* players[game->playerCount];
    for (int i = 0; i < game->playerCount; i++) {
        players[i] = game->players[i];
    }
    sort_players_by_site(players, game->playerCount);
    if (!site_occupied(game, nextSite) && players[0]->pid == pid && 
            players[1]->currentSite > currentSite) {
        return nextSite;
    }
    int numOfOptions = 4;
    int* siteOptions = (int*) calloc(game->path->numOfSites, sizeof(int));

    // Check if can go to next Mo site
    if (game->players[pid]->money % 2 == 1 && 
            get_next_site(game, pid, MO) != -1) {
        siteOptions[0] = get_next_site(game, pid, MO);
    }
    
    // Check if can go to next Ri site
    int playerCardCounts[game->playerCount];
    for (int i = 0; i < game->playerCount; i++) {
        playerCardCounts[i] = game->players[i]->deck->cardCount;
    }
    int maxCardCount = max(playerCardCounts, game->playerCount);
    if ((game->players[pid]->deck->cardCount == maxCardCount || 
            maxCardCount == 0) && get_next_site(game, pid, RI) != -1) {
        siteOptions[1] = get_next_site(game, pid, RI);
    }

    // Check if can go to next V2 site
    if (get_next_site(game, pid, V2) != -1) {
        siteOptions[2] = get_next_site(game, pid, V2);
    }

    // Get the next unoccupied site
    for (int i = nextSite; i < game->path->numOfSites; i++) {
        if (!site_occupied(game, i)) {
            siteOptions[3] = i;
            break;
        }
    }
    free(siteOptions);
    return min(siteOptions, numOfOptions);
}

int get_next_site(Game* game, int pid, Site site) {
    int currentSite = game->players[pid]->currentSite;
    for (int i = currentSite + 1; i < get_next_barrier(
            game->path, currentSite); i++) {
        if (game->path->sites[i] == site && !site_occupied(game, i)) {
            return i;
        }
    }
    return -1;
}