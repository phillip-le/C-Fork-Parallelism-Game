#include "player.h"
#include "path.h"
#include "deck.h"
#include "errors.h"
#include "stdlib.h"
#include "stdbool.h"
#include "deck.h"
#include "utility.h"
#include "stdio.h"
#include "coms.h"
#include "string.h"

Player* init_player(int pid) {
    Player* player = (Player*) malloc(sizeof(Player));
    player->pid = pid;
    player->money = STARTING_MONEY;
    player->V1 = 0;
    player->V2 = 0;
    player->points = 0;
    player->currentSite = 0;
    player->deck = create_deck(0, NULL);
    return player;
}

PlayerGame* init_player_game(int gid, int playerCount, 
        char* pathString) {
    PlayerGame* playerGame = (PlayerGame*) malloc(sizeof(PlayerGame));
    playerGame->gid = gid;
    playerGame->playerCount = playerCount;
    playerGame->path = read_path(pathString, playerCount);
    if (playerGame->path == NULL) {
        free(pathString);
        exit(player_error_msg(PLAYER_BAD_PATH));
    }
    playerGame->players = (Player**) malloc(sizeof(Player*) * playerCount);
    for (int i = 0; i < playerCount; i++) {
        playerGame->players[i] = init_player(i);
    }
    return playerGame;
}

void free_players(Player** players, int playerCount) {
    for (int i = 0; i < playerCount; i++) {
        free_deck(players[i]->deck);
        free(players[i]);
    }
    free(players);
}

void free_player_game(PlayerGame* playerGame) {
    free_players(playerGame->players, playerGame->playerCount);
    free_path(playerGame->path);
    free(playerGame);
}

bool valid_move(Path* path, int currentSite, int destSite) {
    if (site_occupied(path, destSite)) {
        return false;
    }
    if (destSite > get_next_barrier(currentSite, path)) {
        return false;
    }
    return true;
}

void move_player(Path* path, int pid, int destSite) {
    for (int i = 0; i < path->numOfSites; i++) {
        path->playerPositions[i][pid] = UNOCCUPIED;
    }
    path->playerPositions[destSite][pid] = pid;
}

void send_player_update(Path* path, Player* player, int destSite, 
        CARDS nextCard) {
    if (valid_move(path, player->currentSite, destSite)) {
        int* updateInfo = get_player_update(path, player, destSite, nextCard);
        update_player(path, player, updateInfo);
        write_player_update(updateInfo);
        free(updateInfo);
    }
}

void write_player_update(int* updateInfo) {
    char* update = (char*) calloc(30, sizeof(char));
    sprintf(update, "HAP%d,%d,%d,%d,%d\n", updateInfo[PLAYER_ID_INDEX],
            updateInfo[NEW_SITE_INDEX], updateInfo[POINTS_INDEX],
            updateInfo[MONEY_INDEX], updateInfo[CARD_INDEX]);
    fprintf(stdout, "%s", update);
    fflush(stdout);
    free(update);
}

int* get_player_update(Path* path, Player* player, int destSite, 
        CARDS nextCard) {
    int* updateInfo = (int*) calloc(5, sizeof(int));
    switch (path->sites[destSite]) {
        case MO:
            updateInfo[MONEY_INDEX] = 3;
            break;
        case DO:
            updateInfo[POINTS_INDEX] = player->points + 
                    (int) player->money / 2;
            updateInfo[MONEY_INDEX] = player->money * -1;
            break;
        case RI:
            updateInfo[CARD_INDEX] = nextCard;
            break;
        case SITE_ERROR_TYPE:
            free(updateInfo);
            return NULL;
        default:
            break;
    }
    updateInfo[PLAYER_ID_INDEX] = player->pid;
    updateInfo[NEW_SITE_INDEX] = destSite;
    return updateInfo;
}

void update_player(Path* path, Player* player, int* updateInfo) {
    player->currentSite = updateInfo[NEW_SITE_INDEX];
    if (path->sites[updateInfo[NEW_SITE_INDEX]] == V1) {
        player->V1++;
    }
    if (path->sites[updateInfo[NEW_SITE_INDEX]] == V2) {
        player->V2++;
    }
    player->points += updateInfo[POINTS_INDEX];
    player->money += updateInfo[MONEY_INDEX];
    if (updateInfo[CARD_INDEX] != 0) {
        add_card(player->deck, updateInfo[CARD_INDEX]);
    } 
}

void print_player_update(FILE* file, Player* player) {
    fprintf(file, "Player %d Money=%d V1=%d V2=%d ",
            player->pid, player->money, player->V1, player->V2);
    int* cardCounters = get_card_counters(player->deck);
    fprintf(file, "Points=%d A=%d B=%d C=%d D=%d E=%d\n", 
            player->points, cardCounters[0], cardCounters[1], cardCounters[2],
            cardCounters[3], cardCounters[4]);
    fflush(file);
    free(cardCounters);
}

int* read_player_update(PlayerGame* playerGame, char* update) {
    int msgStartLength = 3;
    char msgStart[msgStartLength + 1];
    str_splice(msgStart, update, 0, msgStartLength + 1);
    if (!strcmp(msgStart, "HAP") || update[strlen(update) - 1] != '\n') {
        exit(player_error_msg(PLAYER_COMS));
    }
    // Do not include '\n' when splicing
    char infoString[strlen(update) - 1 - msgStartLength + 1];
    str_splice(infoString, update, msgStartLength, strlen(update) - 1);
    int* info = (int*) calloc(5, sizeof(int));

    char* invalidChar;
    char* intString = strtok(infoString, ",");
    info[0] = strtol(intString, &invalidChar, 10);
    if (invalidChar[0] != '\0') {
        free(info);
        exit(player_error_msg(PLAYER_COMS));
    }
    for (int i = 1; i < 5; i++) {
        intString = strtok(NULL, ",");
        info[i] = strtol(intString, &invalidChar, 10);
        if (invalidChar[0] != '\0') {
            free(info);
            exit(player_error_msg(PLAYER_COMS));
        }
    }
    int pid = info[PLAYER_ID_INDEX];
    int currentSite = playerGame->players[pid]->currentSite;
    if (pid < 0 || pid >= playerGame->playerCount || !valid_move(
            playerGame->path, currentSite, info[NEW_SITE_INDEX]) ||
            info[CARD_INDEX] < 0 || info[CARD_INDEX] > 5) {
        free(info);
        exit(player_error_msg(PLAYER_COMS));
    }
    return info;
}

void recv_player_update(PlayerGame* playerGame, char* update) {
    int* updateInfo = read_player_update(playerGame, update);
    int pid = updateInfo[PLAYER_ID_INDEX];
    move_player(playerGame->path, pid, updateInfo[NEW_SITE_INDEX]);
    update_player(playerGame->path, playerGame->players[pid], updateInfo);
    print_player_update(stderr, playerGame->players[pid]);
}

int calculate_player_score(Player* player) {
    return calculate_deck_score(player->deck) + player->points + player->V1 + 
            player->V2;
}

void check_player_args(int argc, char** argv) {
    if (argc != 4) {
        exit(player_error_msg(PLAYER_ARGS));
    }
    char *invalidChar1, *invalidChar2;
    int playerCount = strtol(argv[2], &invalidChar1, 10);
    if (*invalidChar1 != '\0' || playerCount < 1) {
        exit(player_error_msg(PLAYER_COUNT));
    }
    int pid = strtol(argv[3], &invalidChar2, 10);
    if (*invalidChar2 != '\0' || pid < 0 || pid >= playerCount) {
        exit(player_error_msg(PLAYER_BAD_ID));
    }
}

int get_playerA_move(Path* path, Player* player) {
    int currentSite = player->currentSite;
    int nextSite = currentSite + 1;
    int nextBarrier = get_next_barrier(currentSite, path);
    for (int i = nextSite; i < nextBarrier; i++) {
        if (valid_move(path, player->currentSite, i) && 
                path->sites[i] == DO) {
            return i;
        }
    }
    if (valid_move(path, player->currentSite, nextSite) && 
            path->sites[nextSite] == MO) {
        return nextSite;
    }
    for (int i = nextSite; i < nextBarrier; i++) {
        if (valid_move(path, player->currentSite, i)) {
            Site site = path->sites[i];
            if (site == V1 || site == V2 || site == BARRIER) {
                return i;
            }
        }
    }
    return -1;
}