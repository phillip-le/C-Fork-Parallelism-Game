#include "path.h"
#include "string.h"
#include "stdlib.h"
#include "ctype.h"
#include "stdio.h"
#include "stdbool.h"
#include "utility.h"

Path* read_path(char* pathString, int playerCount) {
    if (pathString == NULL) {
        return NULL;
    }

    // Check for the number of barriers
    char* invalidChar;
    char* numOfSitesString = strtok(pathString, ";");
    int numOfSites = strtol(numOfSitesString, &invalidChar, 10);
    if (invalidChar[0] != '\0') {
        return NULL;
    }
    char* sites = strtok(NULL, ";");
    if ((int) strlen(sites) % SITE_LENGTH != 0) {
        return NULL;
    }
    
    Site* pathSites = (Site*) malloc(sizeof(Site) * numOfSites);
    int* sitePlayerCapacities = (int*) calloc(numOfSites, sizeof(int));
    int capacityIndex = 2;
    int siteNum = 0;
    for (int i = 0; i < (int) strlen(sites); i += SITE_LENGTH) {
        char siteString[SITE_LENGTH + 1];
        str_splice(siteString, sites, i, i + SITE_LENGTH);
        Site site = get_site(siteString);
        if (site != SITE_ERROR_TYPE) {
            pathSites[siteNum] = site;
        } else {
            free(pathSites);
            free(sitePlayerCapacities);
            return NULL;
        }
        if (site == BARRIER) {
            sitePlayerCapacities[siteNum] = playerCount;
        } else {
            sitePlayerCapacities[siteNum] = siteString[capacityIndex] - '0';
        }
        siteNum++;
    }
    if (pathSites[0] != BARRIER || pathSites[numOfSites - 1] != BARRIER) {
        free(pathSites);
        free(sitePlayerCapacities);
        return NULL;
    }
    Path* path = create_path(numOfSites, pathSites, sitePlayerCapacities);
    free(pathSites);
    free(sitePlayerCapacities);
    return path;
}

Path* create_path(int numOfSites, Site* sites, int* sitePlayerCapacities) {
    Path* path = (Path*) malloc (sizeof(Path));
    path->numOfSites = numOfSites;

    path->sites = (Site*) malloc(sizeof(Site) * numOfSites);
    path->sitePlayerCapacities = (int*) calloc(numOfSites, sizeof(int));

    for (int i = 0; i < numOfSites; i++) {
        path->sites[i] = sites[i];
        path->sitePlayerCapacities[i] = sitePlayerCapacities[i];
    }
    return path;
}

void free_path(Path* path) {
    free(path->sites);
    free(path->sitePlayerCapacities);
    free(path);
}

Site get_site(char* site) {
    if (strlen(site) != 3) {
        return SITE_ERROR_TYPE;
    }
    if (!strcmp(site, "::-")) {
        return BARRIER;
    }
    if (!isdigit(site[2]) || site[2] - '0' == 0) {
        return SITE_ERROR_TYPE;
    }
    char* sites[] = {"Mo", "V1", "V2", "Do", "Ri"};
    for (int i = 0; i < 5; i++) {
        char siteLabel[3];
        str_splice(siteLabel, site, 0, 2);
        if (!strcmp(siteLabel, sites[i])) {
            return i;
        }
    }
    return SITE_ERROR_TYPE;
}

char* get_site_string(Site site) {
    switch (site) {
        case BARRIER:
            return "::";
        case MO:
            return "Mo";
        case V1:
            return "V1";
        case V2:
            return "V2";
        case DO:
            return "Do";
        case RI:
            return "Ri";
        case SI:
            return "Si";
        default:
            return NULL;
    }
}

int get_next_barrier(Path* path, int currentSite) {
    for (int i = currentSite + 1; i < path->numOfSites; i++) {
        if (path->sites[i] == BARRIER) {
            return i;
        }
    }
    return -1; // Should never reach here
}