#include "player.h"
#include "path.h"
#include "deck.h"
#include "errors.h"
#include "stdlib.h"
#include "stdbool.h"
#include "deck.h"
#include "utility.h"
#include "stdio.h"
#include "coms.h"
#include "string.h"

Player* init_player(int pid) {
    Player* player = (Player*) malloc(sizeof(Player));
    player->pid = pid;
    player->money = STARTING_MONEY;
    player->V1 = 0;
    player->V2 = 0;
    player->points = 0;
    player->currentSite = 0;
    player->lastTurn = 0;
    player->deck = create_deck(0, NULL);
    return player;
}

void free_players(Player** players, int playerCount) {
    for (int i = 0; i < playerCount; i++) {
        free_deck(players[i]->deck);
        free(players[i]);
    }
    free(players);
}

bool valid_move(Path* path, int currentSite, int destSite) {
    if (site_occupied(path, destSite)) {
        return false;
    }
    if (destSite > get_next_barrier(currentSite, path)) {
        return false;
    }
    return true;
}

void move_player(Path* path, int pid, int destSite) {
    for (int i = 0; i < path->numOfSites; i++) {
        path->playerPositions[i][pid] = UNOCCUPIED;
    }
    path->playerPositions[destSite][pid] = pid;
}

void update_player(Path* path, Player* player, int* updateInfo, 
        int currentTurn) {
    player->currentSite = updateInfo[NEW_SITE_INDEX];
    player->lastTurn = currentTurn;
    if (path->sites[updateInfo[NEW_SITE_INDEX]] == V1) {
        player->V1++;
    }
    if (path->sites[updateInfo[NEW_SITE_INDEX]] == V2) {
        player->V2++;
    }
    player->points += updateInfo[POINTS_INDEX];
    player->money += updateInfo[MONEY_INDEX];
    if (updateInfo[CARD_INDEX] != 0) {
        add_card(player->deck, updateInfo[CARD_INDEX]);
    } 
}

void print_player_update(FILE* file, Player* player) {
    fprintf(file, "Player %d Money=%d V1=%d V2=%d ",
            player->pid, player->money, player->V1, player->V2);
    int* cardCounters = get_card_counters(player->deck);
    fprintf(file, "Points=%d A=%d B=%d C=%d D=%d E=%d\n", 
            player->points, cardCounters[0], cardCounters[1], cardCounters[2],
            cardCounters[3], cardCounters[4]);
    fflush(file);
    free(cardCounters);
}

int calculate_player_score(Player* player) {
    return calculate_deck_score(player->deck) + player->points + player->V1 + 
            player->V2;
}

void check_player_args(int argc, char** argv) {
    if (argc != 4) {
        exit(player_error_msg(PLAYER_ARGS));
    }
    char *invalidChar1, *invalidChar2;
    int playerCount = strtol(argv[2], &invalidChar1, 10);
    if (*invalidChar1 != '\0' || playerCount < 1) {
        exit(player_error_msg(PLAYER_COUNT));
    }
    int pid = strtol(argv[3], &invalidChar2, 10);
    if (*invalidChar2 != '\0' || pid < 0 || pid >= playerCount) {
        exit(player_error_msg(PLAYER_BAD_ID));
    }
}

int get_playerA_move(Path* path, Player* player) {
    int currentSite = player->currentSite;
    int nextSite = currentSite + 1;
    int nextBarrier = get_next_barrier(currentSite, path);
    for (int i = nextSite; i < nextBarrier; i++) {
        if (valid_move(path, player->currentSite, i) && 
                path->sites[i] == DO) {
            return i;
        }
    }
    if (valid_move(path, player->currentSite, nextSite) && 
            path->sites[nextSite] == MO) {
        return nextSite;
    }
    for (int i = nextSite; i < nextBarrier; i++) {
        if (valid_move(path, player->currentSite, i)) {
            Site site = path->sites[i];
            if (site == V1 || site == V2 || site == BARRIER) {
                return i;
            }
        }
    }
    return -1;
}