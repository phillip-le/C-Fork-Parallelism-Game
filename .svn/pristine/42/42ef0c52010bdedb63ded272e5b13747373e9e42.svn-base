#include "coms.h"
#include "game.h"
#include "player.h"
#include "errors.h"
#include "deck.h"
#include "stdlib.h"
#include "utility.h"
#include "string.h"
#include "unistd.h"

void send_msg_to_all_player(Dealer* dealer, char* msg) {
    for (int i = 0; i < dealer->game->playerCount; i++) {
        fprintf(dealer->comStreams[i][STDIN_FILENO], "%s", msg);
        fflush(dealer->comStreams[i][STDIN_FILENO]);
    }
}

void send_path(Dealer* dealer, char* pathString) {
    for (int i = 0; i < dealer->game->playerCount; i++) {
        char msg = fgetc(dealer->comStreams[i][STDOUT_FILENO]);
        if (msg != '^') {
            end_early(dealer);
        } else {
            fprintf(dealer->comStreams[i][STDIN_FILENO], "%s\n", pathString);
            fflush(dealer->comStreams[i][STDIN_FILENO]);
        }
    }
}

bool recv_dealer_msg(Game* game, int pid, char* msg) {
    if (!strcmp(msg, "YT")) {
        return true;
    }
    if (!strcmp(msg, "EARLY")) {
        exit(player_error_msg(EARLY_GAME_END));
    }
    if (!strcmp(msg, "DONE")) {
        print_scores(stderr, game);
        exit(player_error_msg(PLAYER_OK));
    }
    // Program will exit if an error occurred
    recv_player_update(game, msg);
    return false;
}

int recv_player_move(Dealer* dealer) {
    int nextPlayer = get_next_turn(dealer->game);
    fprintf(dealer->comStreams[nextPlayer][STDIN_FILENO], 
            "YT\n");
    fflush(dealer->comStreams[nextPlayer][STDIN_FILENO]);
    char* playerMove = read_line(
            dealer->comStreams[nextPlayer][STDOUT_FILENO]);
    if (playerMove == NULL || playerMove[0] != 'D' || playerMove[1] != 'O') {
        end_early(dealer);
    }
    char* invalidChar;
    int siteNum = strtol(playerMove + 2, &invalidChar, 10);
    if (*invalidChar != '\0') {
        end_early(dealer);
    }
    return siteNum;
}

void send_player_update(Dealer* dealer, int pid, int destSite) {
    if (!valid_move(dealer->game, pid, destSite)) {
        end_early(dealer);
    }
    int* updateInfo = get_player_update(dealer, pid, destSite);
    dealer->game->turnCounter++;
    update_player(dealer->game->path, dealer->game->players[pid], updateInfo, 
            dealer->game->turnCounter);
    char* update = get_update_string(updateInfo);
    send_msg_to_all_player(dealer, update);
    free(update);
    print_player_update(stdout, dealer->game->players[pid]);
    print_path(stdout, dealer->game);
    free(updateInfo);
}

char* get_update_string(int* updateInfo) {
    char* update = (char*) calloc(30, sizeof(char));
    sprintf(update, "HAP%d,%d,%d,%d,%d\n", updateInfo[PLAYER_ID_INDEX],
            updateInfo[NEW_SITE_INDEX], updateInfo[POINTS_INDEX],
            updateInfo[MONEY_INDEX], updateInfo[CARD_INDEX]);
    return update;
}

int* get_player_update(Dealer* dealer, int pid, int destSite) {
    int* updateInfo = (int*) calloc(5, sizeof(int));
    switch (dealer->game->path->sites[destSite]) {
        case MO:
            updateInfo[MONEY_INDEX] = 3;
            break;
        case DO:
            updateInfo[POINTS_INDEX] = dealer->game->players[pid]->points + 
                    (int) dealer->game->players[pid]->money / 2;
            updateInfo[MONEY_INDEX] = dealer->game->players[pid]->money * -1;
            break;
        case RI:
            updateInfo[CARD_INDEX] = dealer->deck->cards[dealer->nextCard];
            next_card(dealer);
            break;
        case SITE_ERROR_TYPE:
            free(updateInfo);
            return NULL;
        default:
            break;
    }
    updateInfo[PLAYER_ID_INDEX] = pid;
    updateInfo[NEW_SITE_INDEX] = destSite;
    return updateInfo;
}

void recv_player_update(Game* game, char* update) {
    int* updateInfo = read_player_update(game, update);
    int pid = updateInfo[PLAYER_ID_INDEX];
    game->turnCounter++;
    update_player(game->path, game->players[pid], updateInfo, 
            game->turnCounter);
    print_player_update(stderr, game->players[pid]);
    print_path(stderr, game);
}

int* read_player_update(Game* game, char* update) {
    int msgStartLength = 3;
    char msgStart[msgStartLength + 1];
    str_splice(msgStart, update, 0, msgStartLength);
    if (strcmp(msgStart, "HAP")) {
        exit(player_error_msg(PLAYER_COMS));
    }
    char infoString[strlen(update) - msgStartLength + 1];

    str_splice(infoString, update, msgStartLength, strlen(update));
    int* info = (int*) calloc(5, sizeof(int));
    char* invalidChar;
    char* intString = strtok(infoString, ",");
    info[0] = strtol(intString, &invalidChar, 10);
    if (invalidChar[0] != '\0') {
        free(info);
        exit(player_error_msg(PLAYER_COMS));
    }
    for (int i = 1; i < 5; i++) {
        intString = strtok(NULL, ",");
        info[i] = strtol(intString, &invalidChar, 10);
        if (invalidChar[0] != '\0') {
            free(info);
            exit(player_error_msg(PLAYER_COMS));
        }
    }
    int pid = info[PLAYER_ID_INDEX];
    if (pid < 0 || pid >= game->playerCount || !valid_move(game, pid, 
            info[NEW_SITE_INDEX]) || info[CARD_INDEX] < 0 || 
            info[CARD_INDEX] > 5) {
        free(info);
        exit(player_error_msg(PLAYER_COMS));
    }
    return info;
}

void print_player_update(FILE* file, Player* player) {
    fprintf(file, "Player %d Money=%d V1=%d V2=%d ",
            player->pid, player->money, player->V1, player->V2);
    int* cardCounters = get_card_counters(player->deck);
    fprintf(file, "Points=%d A=%d B=%d C=%d D=%d E=%d\n", 
            player->points, cardCounters[0], cardCounters[1], cardCounters[2],
            cardCounters[3], cardCounters[4]);
    fflush(file);
    free(cardCounters);
}

void print_path(FILE* file, Game* game) {
    int pathStringSize = game->path->numOfSites * 3 + 1;
    // Stores the highest number of players at any site
    int highestSiteOccupancy = get_highest_occupied(game);
    char* pathString = (char*) calloc(pathStringSize, sizeof(char));
    char** positionStrings = create_position_strings(highestSiteOccupancy,
            pathStringSize);
    int siteOffset[game->path->numOfSites];
    // Get site labels
    int pathStringIndex = 0;
    for (int i = 0; i < game->path->numOfSites; i++) {
        siteOffset[i] = pathStringIndex;
        Site site = game->path->sites[i];
        strncat(pathString, get_site_string(site), 2);
        pathStringIndex += 2;
        pathString[pathStringIndex++] = ' ';
    }
    fill_position_strings(game, positionStrings, highestSiteOccupancy, 
            siteOffset);
    fprintf(file, "%s\n", pathString);
    for (int i = 0; i < highestSiteOccupancy; i++) {
        fprintf(file, "%s\n", positionStrings[i]);
    }
    fflush(file);
    free(pathString);
    for (int i = 0; i < highestSiteOccupancy; i++) {
        free(positionStrings[i]);
    }
    free(positionStrings);
}

int get_highest_occupied(Game* game) {
    int playerSites[game->playerCount];
    for (int i = 0; i < game->playerCount; i++) {
        playerSites[i] = game->players[i]->currentSite;
    }
    int numOfSites = game->path->numOfSites;
    int siteCounters[numOfSites];
    for (int i = 0; i < numOfSites; i++) {
        siteCounters[i] = 0;
    }
    for (int i = 0; i < game->playerCount; i++) {
        siteCounters[playerSites[i]]++;
    }
    return max(siteCounters, numOfSites);
}

char** create_position_strings(int highestSiteOccupancy, int pathStringSize) {
    char** positionStrings = (char**) malloc(
            sizeof(char*) * highestSiteOccupancy);
    for (int i = 0; i < highestSiteOccupancy; i++) {
        positionStrings[i] = (char*) malloc(sizeof(char) * pathStringSize);
        for (int j = 0; j < pathStringSize - 1; j++) {
            positionStrings[i][j] = ' ';
        }
        positionStrings[i][pathStringSize - 1] = '\0';
    }
    return positionStrings;
}

void fill_position_strings(Game* game, char** positionStrings, 
        int highestSiteOccupancy, int* siteOffset) {
    int turnOrder[game->playerCount];
    get_turn_order(game, turnOrder);
    for (int i = game->playerCount - 1; i >= 0; i--) {
        int pid = turnOrder[i];
        int siteNum = game->players[pid]->currentSite;
        for (int j = 0; j < highestSiteOccupancy; j++) {
            if (positionStrings[j][siteOffset[siteNum]] == ' ') {
                positionStrings[j][siteOffset[siteNum]] = pid + '0';
                break;
            }
        }
    }
}

void end_early(Dealer* dealer) {
    send_msg_to_all_player(dealer, "EARLY\n");
    exit(dealer_error_msg(DEALER_COMS));
}

void print_scores(FILE* file, Game* game) {
    fprintf(file, "Scores: ");
    for (int i = 0; i < game->playerCount - 1; i++) {
        fprintf(file, "%d,", calculate_player_score(game->players[i]));
    }
    fprintf(file, "%d\n", calculate_player_score(game->players[
            game->playerCount - 1]));
    fflush(file);
}