#include "game.h"
#include "path.h"
#include "player.h"
#include "errors.h"
#include "deck.h"
#include "stdbool.h"
#include "utility.h"
#include "stdlib.h"

Game* init_game(int gid, int playerCount, char* pathString) {
    Game* game = (Game*) malloc(sizeof(Game));
    game->gid = gid;
    game->playerCount = playerCount;
    game->turnCounter = 0;
    game->path = read_path(pathString, playerCount);
    if (game->path == NULL) {
        free(game);
        return NULL;
    }
    game->players = (Player**) malloc(sizeof(Player*) * playerCount);
    for (int i = 0; i < playerCount; i++) {
        game->players[i] = init_player(i);
    }
    return game;
}

void free_game(Game* game) {
    free_players(game->players, game->playerCount);
    free_path(game->path);
    free(game);
}

int get_next_turn(Game* game) {
    int turnOrder[game->playerCount];
    get_turn_order(game, turnOrder);
    return turnOrder[0];
}

void get_turn_order(Game* game, int* turnOrder) {
    Player* players[game->playerCount];
    for (int i = 0; i < game->playerCount; i++) {
        players[i] = game->players[i];
    }
    sort_players_by_site(players, game->playerCount);
    sort_players_same_site(players, game->playerCount);
    for (int i = 0; i < game->playerCount; i++) {
        turnOrder[i] = players[i]->pid;
    }
}

void sort_players_by_site(Player** players, int playerCount) {
    bool sorted = false;
    while (!sorted) {
        sorted = true;
        for (int i = 0; i < playerCount - 1; i++) {
            if (players[i]->currentSite > players[i + 1]->currentSite) {
                swap_players(players, i, i + 1);
                sorted = false;
            }
        }
    }
}

void sort_players_same_site(Player** players, int playerCount) {
    bool sorted = false;
    while (!sorted) {
        sorted = true;
        for (int i = 0; i < playerCount - 1; i++) {
            if (players[i]->currentSite == players[i + 1]->currentSite) {
                if (players[i]->lastTurn < players[i + 1]->lastTurn) {
                    swap_players(players, i, i + 1);
                    sorted = false;
                } else if (players[i]->lastTurn == players[i + 1]->lastTurn &&
                        players[i]->pid < players[i + 1]->pid) {
                    swap_players(players, i, i + 1);
                    sorted = false;
                }
            }
        }
    }
}

Dealer* init_dealer(int playerCount, char* deckString, 
        char* pathString) {
    Dealer* dealer = (Dealer*) malloc(sizeof(Dealer));
    dealer->game = init_game(DEALER_ID, playerCount, pathString);
    if (dealer->game == NULL) {
        exit(dealer_error_msg(BAD_PATH));
    }
    dealer->deck = read_deck(deckString);
    if (dealer->deck == NULL) {
        exit(dealer_error_msg(BAD_DECK));
    }
    dealer->nextCard = 0;
    return dealer;
}

void next_card(Dealer* dealer) {
    dealer->nextCard++;
    if (dealer->nextCard == dealer->deck->cardCount) {
        dealer->nextCard = 0;
    }
}

void swap_players(Player** players, int i, int j) {
    Player* temp = players[i];
    players[i] = players[j];
    players[j] = temp;
}

bool valid_move(Game* game, int pid, int destSite) {
    if (site_occupied(game, destSite)) {
        return false;
    }
    if (destSite > get_next_barrier(
            game->path, game->players[pid]->currentSite)) {
        return false;
    }
    return true;
}

bool site_occupied(Game* game, int siteNum) {
    int sitePlayerCount = 0;
    for (int i = 0; i < game->playerCount; i++) {
        if (game->players[i]->currentSite == siteNum) {
            sitePlayerCount++;
        }
    }
    if (sitePlayerCount >= game->path->sitePlayerCapacities[siteNum]) {
        return true;
    }
    return false;
}

bool game_over(Game* game) {
    for (int i = 0; i < game->playerCount; i++) {
        if (!(game->players[i]->currentSite == game->path->numOfSites - 1)) {
            return false;
        }
    }
    return true;
}

int get_next_site(Game* game, int pid, Site site) {
    int currentSite = game->players[pid]->currentSite;
    for (int i = currentSite + 1; i < get_next_barrier(
            game->path, currentSite); i++) {
        if (game->path->sites[i] == site && !site_occupied(game, i)) {
            return i;
        }
    }
    return -1;
}