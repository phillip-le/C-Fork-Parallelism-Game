#include "stdlib.h"
#include "stdlib.h"
#include "stdio.h"
#include "deck.h"
#include "string.h"
#include "stdbool.h"

void test_deck(DECK* deck) {
    printf("%d\n", deck->cardCount);
    for (int i = 0; i < deck->cardCount; i++) {
        printf("%c", get_card_char(deck->cards[i]));
    }
    printf("\n");
    fflush(stdout);
}

/**
 * Takes a '\n' terminated string.
 */
DECK* read_deck(char* deckString) {
    char* cardsString;
    int cardCount = strtol(deckString, &cardsString, 10);
    if (cardsString[strlen(cardsString) - 1] != '\n' || 
            cardsString[0] == '\0' || cardsString == deckString ||
            (int) strlen(cardsString) != cardCount + 1) {
        return NULL;
    }
    CARDS* cards = (CARDS*) malloc(sizeof(CARDS) * cardCount);
    int cardCounter = 0;
    for (int i = 0; i < cardCount; i++) {
        if (get_card(cardsString[i]) == CARD_INVALID) {
            free(cards);
            return NULL;
        } else {
            cards[i] = get_card(cardsString[i]);
            cardCounter++;
        }
    }
    if (cardCounter != cardCount) {
        free(cards);
        return NULL;
    }
    DECK* deck = create_deck(cardCount, cards);
    free(cards);
    return deck;
}

DECK* create_deck(int cardCount, CARDS* cards) {
    DECK* deck = (DECK*) malloc(sizeof(DECK));
    deck->cardCount = cardCount;
    deck->cards = (CARDS*) malloc(sizeof(CARDS) * cardCount);
    for (int i = 0; i < cardCount; i++) {
        deck->cards[i] = cards[i];
    }
    return deck;
}

void free_deck(DECK* deck) {
    free(deck->cards);
    free(deck);
}

void add_card(DECK* deck, CARDS card) {
    deck->cardCount++;
    realloc(deck->cards, deck->cardCount);
    deck->cards[deck->cardCount - 1] = card;
}

int calculate_score(DECK* deck) {
    int cardCounters[UNIQUE_CARD_COUNT] = {0, 0, 0, 0, 0};
    for (int i = 0; i < deck->cardCount; i++) {
        switch (deck->cards[i]) {
            case CARD_A:
                cardCounters[0] += 1;
                break;
            case CARD_B:
                cardCounters[1]++;
                break;
            case CARD_C:
                cardCounters[2]++;
                break;
            case CARD_D:
                cardCounters[3]++;
                break;
            case CARD_E:
                cardCounters[4]++;
                break;
        }
    }
    // int completeSetCounter = 0, completeSet = 1;
    // while (completeSet) {
    //     completeSet = 1;
    //     for (int i = 0; i < UNIQUE_CARD_COUNT; i++) {
    //         completeSet &= cardCounters[i];
    //     }
    //     if (completeSet) {
    //         completeSetCounter++;
    //         for (int i = 0; i < UNIQUE_CARD_COUNT; i++) {
    //             cardCounters[i]--;
    //         }
    //     }
    // }
}

CARDS get_card(char card) {
    switch (card) {
        case 'A':
            return CARD_A;
        case 'B':
            return CARD_B;
        case 'C':
            return CARD_C;
        case 'D':
            return CARD_D;
        case 'E':
            return CARD_E;
        default:
            return CARD_INVALID;
    }
}

char get_card_char(CARDS card) {
    switch (card) {
        case CARD_A:
            return 'A';
        case CARD_B:
            return 'B';
        case CARD_C:
            return 'C';
        case CARD_D:
            return 'D';
        case CARD_E:
            return 'E';
        default:
            return 0;
    }
}